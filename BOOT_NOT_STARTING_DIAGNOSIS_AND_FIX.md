# ?? CRITICAL: Service Not Starting On Boot - Complete Diagnosis & Fix

## The Problem

**After device reboot, the service STILL doesn't start until you open the app.**

This means:
- ? Boot receiver not triggering at all, OR
- ? Boot receiver triggers but service fails to start, OR
- ? Service starts but immediately crashes/stops, OR
- ? Android is killing the service before it can initialize

---

## ?? Step-by-Step Diagnosis

### Diagnostic 1: Is Boot Receiver Even Registered?

```powershell
# Check if receiver is registered in the package
adb shell dumpsys package com.companyname.obsidianscout | findstr "Receiver"
```

**Expected output:**
```
crc64f3faeb7d35d8db75.DeviceBootReceiver
crc64f3faeb7d35d8db75.BootReceiver
crc64f3faeb7d35d8db75.ServiceRestartReceiver
```

**? If you see NOTHING or wrong class names:**
? **PROBLEM:** Receivers not registered properly
? **FIX:** Need to rebuild with correct class names

### Diagnostic 2: Test Boot Receiver Manually

```powershell
# Simulate boot (test if receiver responds)
adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -p com.companyname.obsidianscout

# Check logs immediately
adb logcat -d | findstr "DeviceBootReceiver\|BootReceiver"
```

**Expected output:**
```
[DeviceBootReceiver] ===== BOOT RECEIVED =====
[DeviceBootReceiver] Action: android.intent.action.BOOT_COMPLETED
```

**? If you see NOTHING:**
? **PROBLEM:** Receiver not responding to broadcast
? **FIX:** Receiver disabled or wrong intent filter

### Diagnostic 3: Check App Launch Flag

```powershell
# Check if flag is set
adb shell "run-as com.companyname.obsidianscout ls /data/data/com.companyname.obsidianscout/files/.app_launched"
```

**Expected:** File exists

**? If file not found:**
? **PROBLEM:** App wasn't opened after install
? **FIX:** Open app, then reboot

### Diagnostic 4: Check Actual Reboot Logs

```powershell
# Clear logs, reboot, check logs
adb logcat -c
adb reboot

# Wait 2 minutes for boot
Start-Sleep -Seconds 120

# Check logs (WITHOUT device attached to debugger)
adb logcat -d > boot_logs.txt
notepad boot_logs.txt
# Search for: "DeviceBootReceiver", "BootReceiver", "ForegroundService"
```

**Expected in logs:**
```
[DeviceBootReceiver] ===== BOOT RECEIVED =====
[DeviceBootReceiver] App launched once: true
[ForegroundService] OnCreate called
```

**? If DeviceBootReceiver not in logs:**
? **CRITICAL PROBLEM:** Receiver not triggering on actual boot
? **FIX:** See "Ultimate Fix" below

---

## ? Ultimate Fix - Make Boot Receiver Work 100%

The issue is likely that the **Java class name generated by .NET MAUI doesn't match** what's in the manifest. Let me create a foolproof solution:

### Fix 1: Use Correct Generated Class Name

Update `AndroidManifest.xml` to use the ACTUAL generated class name:

```powershell
# First, find the ACTUAL generated class name
adb shell dumpsys package com.companyname.obsidianscout | findstr "Receiver" > receivers.txt
notepad receivers.txt
```

Look for something like:
```
crc64abc123def456.DeviceBootReceiver
```

That `crc64abc123def456` is the ACTUAL prefix .NET MAUI generated.

**Update AndroidManifest.xml with the REAL class name:**

```xml
<!-- Use the ACTUAL generated class name from dumpsys -->
<receiver
    android:name="crc64abc123def456.DeviceBootReceiver"
    android:enabled="true"
    android:exported="true"
    android:directBootAware="true">
 <intent-filter android:priority="1000">
        <action android:name="android.intent.action.BOOT_COMPLETED" />
      <action android:name="android.intent.action.LOCKED_BOOT_COMPLETED" />
        <action android:name="android.intent.action.QUICKBOOT_POWERON" />
    </intent-filter>
</receiver>
```

### Fix 2: Simplify Boot Receiver (Remove Complexity)

The current boot receiver might be too complex. Let's create a MINIMAL version that definitely works:

Create `ObsidianScout/Platforms/Android/SimpleBootReceiver.cs`:

```csharp
using Android.App;
using Android.Content;
using Android.OS;
using Android.Util;

namespace ObsidianScout.Platforms.Android
{
    [BroadcastReceiver(Enabled = true, Exported = true, DirectBootAware = true)]
    [IntentFilter(new[] { Intent.ActionBootCompleted, Intent.ActionLockedBootCompleted })]
    public class SimpleBootReceiver : BroadcastReceiver
    {
        private const string TAG = "SimpleBootReceiver";

        public override void OnReceive(Context? context, Intent? intent)
        {
        Log.Debug(TAG, "===== BOOT RECEIVED (SIMPLE) =====");
     
            if (context == null || intent == null)
     {
        Log.Error(TAG, "Context or intent is null");
    return;
   }

    var action = intent.Action;
      Log.Debug(TAG, $"Action: {action}");

// Check if app was launched at least once
     try
      {
      var appLaunched = PersistentPreferences.GetAppLaunched(context);
       Log.Debug(TAG, $"App launched once: {appLaunched}");

    if (!appLaunched)
    {
           Log.Warn(TAG, "App never launched - showing reminder");
          ShowReminder(context);
           return;
  }

                // Start service
      Log.Debug(TAG, "Starting ForegroundNotificationService...");
     var serviceIntent = new Intent(context, typeof(ForegroundNotificationService));
        serviceIntent.PutExtra("started_from_boot", true);

          if (Build.VERSION.SdkInt >= BuildVersionCodes.O)
     {
 context.StartForegroundService(serviceIntent);
        }
          else
  {
        context.StartService(serviceIntent);
                }

    Log.Debug(TAG, "Service start command sent");
        }
    catch (System.Exception ex)
            {
     Log.Error(TAG, $"Error: {ex.Message}");
        Log.Error(TAG, $"Stack: {ex.StackTrace}");
            }
}

        private void ShowReminder(Context context)
        {
            try
            {
 var nm = (NotificationManager?)context.GetSystemService(Context.NotificationService);
           if (nm == null) return;

    const string channelId = "obsidian_scout_channel";

       if (Build.VERSION.SdkInt >= BuildVersionCodes.O)
     {
           var channel = new NotificationChannel(
       channelId,
        "ObsidianScout",
NotificationImportance.High);
        nm.CreateNotificationChannel(channel);
     }

   var launchIntent = context.PackageManager?.GetLaunchIntentForPackage(context.PackageName!);
        launchIntent?.AddFlags(ActivityFlags.NewTask);

   var pendingIntent = PendingIntent.GetActivity(
        context,
        0,
          launchIntent,
        Build.VERSION.SdkInt >= BuildVersionCodes.S
          ? PendingIntentFlags.Immutable
    : PendingIntentFlags.UpdateCurrent);

         var notification = new AndroidX.Core.App.NotificationCompat.Builder(context, channelId)
 .SetContentTitle("ObsidianScout")
         .SetContentText("Tap to enable notifications after restart")
     .SetSmallIcon(global::Android.Resource.Drawable.IcDialogInfo)
      .SetContentIntent(pendingIntent)
        .SetAutoCancel(true)
        .Build();

          nm.Notify(1000, notification);
       Log.Debug(TAG, "Reminder notification shown");
   }
     catch (System.Exception ex)
        {
        Log.Error(TAG, $"Reminder error: {ex.Message}");
            }
        }
    }
}
```

### Fix 3: Ensure Manifest is Correct

Update `Platforms/Android/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <!-- Permissions -->
<uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_DATA_SYNC" />
    <uses-permission android:name="android.permission.WAKE_LOCK" />
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
    <uses-permission android:name="android.permission.SCHEDULE_EXACT_ALARM" />
    <uses-permission android:name="android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS" />

    <application>
        <!-- Service -->
        <service
          android:name="crc64f3faeb7d35d8db75.ForegroundNotificationService"
    android:enabled="true"
   android:exported="false"
        android:foregroundServiceType="dataSync"
            android:stopWithTask="false" />

        <!-- SIMPLE boot receiver - just starts service, nothing else -->
        <receiver
     android:name="crc64f3faeb7d35d8db75.SimpleBootReceiver"
            android:enabled="true"
            android:exported="true"
android:directBootAware="true">
  <intent-filter android:priority="999">
             <action android:name="android.intent.action.BOOT_COMPLETED" />
     <action android:name="android.intent.action.LOCKED_BOOT_COMPLETED" />
            </intent-filter>
   </receiver>
    </application>
</manifest>
```

### Fix 4: Alternative Approach - WorkManager

If broadcast receivers continue to fail, use WorkManager (more reliable):

Add to `.csproj`:
```xml
<PackageReference Include="Xamarin.AndroidX.Work.Runtime" Version="2.9.0" />
```

Create `ObsidianScout/Platforms/Android/BootWorker.cs`:

```csharp
using Android.Content;
using AndroidX.Work;
using System;

namespace ObsidianScout.Platforms.Android
{
    public class BootWorker : Worker
    {
    public BootWorker(Context context, WorkerParameters workerParams)
            : base(context, workerParams)
        {
      }

      public override Result DoWork()
        {
       try
       {
        System.Diagnostics.Debug.WriteLine("[BootWorker] Starting service from WorkManager");

  var context = ApplicationContext;
    var intent = new Intent(context, typeof(ForegroundNotificationService));
                intent.PutExtra("started_from_boot", true);

 if (global::Android.OS.Build.VERSION.SdkInt >= global::Android.OS.BuildVersionCodes.O)
             {
         context.StartForegroundService(intent);
        }
       else
        {
   context.StartService(intent);
   }

          return Result.InvokeSuccess();
   }
    catch (Exception ex)
       {
    System.Diagnostics.Debug.WriteLine($"[BootWorker] Error: {ex.Message}");
          return Result.InvokeRetry();
   }
     }
    }
}
```

In `SimpleBootReceiver.OnReceive()`, schedule the worker:

```csharp
// After checking app launched flag
if (appLaunched)
{
    // Schedule work
    var workRequest = OneTimeWorkRequest.Builder.From<BootWorker>()
    .SetInitialDelay(TimeSpan.FromSeconds(10))
        .Build();
    
    WorkManager.GetInstance(context).Enqueue(workRequest);
    Log.Debug(TAG, "Scheduled BootWorker");
}
```

---

## ?? Complete Test Procedure

### Test 1: Verify Receivers Are Registered

```powershell
# After deploying, check registration
adb shell dumpsys package com.companyname.obsidianscout | findstr "Receiver"
```

**Must show:** `SimpleBootReceiver` (or DeviceBootReceiver)

### Test 2: Test Manually

```powershell
# Test broadcast
adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -p com.companyname.obsidianscout

# Check logs immediately
adb logcat | findstr "SimpleBootReceiver\|DeviceBootReceiver"
```

**Must show:** "BOOT RECEIVED (SIMPLE)"

### Test 3: Actual Reboot

```powershell
# Clear logs
adb logcat -c

# Reboot
adb reboot

# Wait 2 minutes
Start-Sleep -Seconds 120

# Check logs
adb logcat -d | findstr "SimpleBootReceiver\|ForegroundService" > reboot_test.txt
notepad reboot_test.txt
```

**Must show:**
1. SimpleBootReceiver triggered
2. ForegroundService started
3. BackgroundNotificationService initialized

---

## ?? Emergency Workaround (If All Else Fails)

If boot receivers absolutely won't work, use AlarmManager to schedule periodic restarts:

In `MainActivity.OnCreate()`:

```csharp
// Schedule periodic service check (every 15 minutes)
var alarmManager = (AlarmManager?)GetSystemService(AlarmService);
if (alarmManager != null)
{
    var intent = new Intent(this, typeof(ForegroundNotificationService));
    var pendingIntent = PendingIntent.GetService(
this,
        0,
  intent,
     Build.VERSION.SdkInt >= BuildVersionCodes.S
      ? PendingIntentFlags.Immutable
  : PendingIntentFlags.UpdateCurrent);

    // Repeat every 15 minutes
    alarmManager.SetInexactRepeating(
   AlarmType.ElapsedRealtimeWakeup,
        SystemClock.ElapsedRealtime() + 900000, // 15 min
  900000, // 15 min
        pendingIntent);
}
```

---

## ?? Common Issues & Solutions

| Issue | Cause | Solution |
|-------|-------|----------|
| Receiver not in dumpsys | Wrong class name in manifest | Use `adb shell dumpsys` to get real name |
| Receiver doesn't respond | Wrong intent filter | Use only BOOT_COMPLETED |
| Service starts then dies | Battery optimization | Whitelist app |
| No logs after boot | Logs cleared | Use `adb logcat -d` after boot |
| Works manually, not on boot | Android delays boot receivers | Add 10s delay before starting service |

---

## ? Final Checklist

Before saying "it works":

- [ ] Receiver shows in `dumpsys package`
- [ ] Manual broadcast triggers receiver
- [ ] Actual reboot triggers receiver (check logs)
- [ ] Service starts after reboot
- [ ] Service stays running for 30+ minutes
- [ ] Notifications poll after reboot
- [ ] Works after 3+ reboots

---

*Critical Boot Fix - January 2025*  
*Status: Diagnosis & Multiple Solutions*
